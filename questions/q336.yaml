question: |-
  ```rust
  fn main() {
      let iter1 = 1..=3;
      let iter2 = 4..=6;
      
      let chained: Vec<_> = iter1.chain(iter2).collect();
      println!("{:?}", chained);
  }
  ```

  What does this program print?
answers:
- '[1, 2, 3, 4, 5, 6]'
- '[(1, 4), (2, 5), (3, 6)]'
- '[1, 4, 2, 5, 3, 6]'
- Compilation error
correct_answer: 0
expected_output:
- '[1, 2, 3, 4, 5, 6]'
explanation: |-
  This question tests understanding of the `chain()` method in Rust's iterator
  API. The `chain()` method is used to concatenate two iterators sequentially,
  creating a single iterator that yields all elements from the first iterator
  followed by all elements from the second iterator.

  In this code, two range iterators are created: `iter1` (1..=3) and `iter2`
  (4..=6). When `iter1.chain(iter2)` is called, it creates a new iterator that
  first yields all elements from `iter1` (1, 2, 3) and then yields all elements
  from `iter2` (4, 5, 6). The `collect()` method then gathers these elements into
  a vector.

  The result is `[1, 2, 3, 4, 5, 6]`, demonstrating that `chain()` preserves the
  order of elements and processes iterators sequentially rather than interleaving
  them.

  The key takeaway is that `chain()` is the standard way to concatenate iterators
  in Rust, producing a sequential combination. This is distinct from other
  iterator combinators like `zip()`, which would pair elements from both iterators
  together, or `interleave()` (from external crates), which would alternate
  between elements.
