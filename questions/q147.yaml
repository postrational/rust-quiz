question: |-
  ```rust
  use tokio::time::{sleep, Duration};

  async fn task(id: u32, delay_ms: u64) -> u32 {
      println!("Task {} starting", id);
      sleep(Duration::from_millis(delay_ms)).await;
      println!("Task {} finished", id);
      id * 10
  }

  #[tokio::main]
  async fn main() {
      let futures = vec![
          task(1, 300),
          task(2, 100), 
          task(3, 200),
      ];
      
      let results = futures_util::future::join_all(futures).await;
      println!("Results: {:?}", results);
  }
  ```

  What's the output of this concurrent async execution?
answers:
- Tasks print in order 1,2,3 starting, then 1,2,3 finishing, results [10,20,30]
- Tasks start 1,2,3, finish 2,3,1, results [10,20,30]
- Compilation error - cannot move futures into vec
- Tasks start and finish in random order, results [10,20,30]
correct_answer: 1
expected_output:
- Task 1 starting
- Task 2 starting
- Task 3 starting
- Task 2 finished
- Task 3 finished
- Task 1 finished
- 'Results: [10, 20, 30]'
explanation: |-
  This question tests understanding of concurrent async execution with `join_all`
  in Rust's async runtime.

  When `join_all` is called on a vector of futures, it starts executing all
  futures concurrently. The futures are not executed sequentially; instead, they
  all begin execution immediately and run in parallel within the async runtime.

  In this code, all three tasks start in order (1, 2, 3) because they are created
  and added to the vector sequentially. Each task prints its starting message,
  then begins sleeping for its specified duration. Since the tasks run
  concurrently, they finish based on their sleep durations: Task 2 finishes first
  (100ms), then Task 3 (200ms), and finally Task 1 (300ms).

  The results vector maintains the original order of the futures regardless of
  completion order. So even though Task 2 completes first, its result (20) appears
  in the second position of the results vector, producing `[10, 20, 30]`.

  The key takeaway is that `join_all` enables concurrent execution of multiple
  async tasks, allowing faster tasks to complete before slower ones, while
  preserving the original ordering in the results. This is different from
  sequential execution where tasks would complete in the order they were started.
