question: |-
  ```rust
  use std::collections::HashMap;

  fn main() {
      let text = "hello world hello rust world";
      let mut counts: HashMap<&str, usize> = HashMap::new();
      
      for word in text.split_whitespace() {
          *counts.entry(word).or_insert(0) += 1;
      }
      
      let max_count = counts.values().max().unwrap();
      let mut frequent_words: Vec<&str> = counts
          .iter()
          .filter(|(_, &count)| count == *max_count)
          .map(|(&word, _)| word)
          .collect();
      
      frequent_words.sort();
      
      println!("Max count: {}", max_count);
      println!("Most frequent: {:?}", frequent_words);
  }
  ```

  What is the output of this code?
answers:
- 'Max count: 1, Most frequent: ["rust"]'
- 'Max count: 2, Most frequent: ["hello"]'
- 'Max count: 2, Most frequent: ["hello", "world"]'
- 'Max count: 3, Most frequent: ["hello", "world", "rust"]'
correct_answer: 2
expected_output:
- 'Max count: 2'
- 'Most frequent: ["hello", "world"]'
explanation: |-
  This question tests understanding of HashMap operations, the Entry API, and
  working with references in Rust.

  The code counts word frequencies in the text "hello world hello rust world". The
  Entry API's `or_insert(0)` method returns a mutable reference (`&mut usize`) to
  the value, which is why dereferencing with `*` is needed before incrementing.
  This design allows efficient in-place modification of the HashMap value without
  copying.

  The word frequencies are:
  - "hello": 2 occurrences
  - "world": 2 occurrences  
  - "rust": 1 occurrence

  The code finds the maximum count (2) using `values().max()`, which returns
  `Option<&usize>`. After unwrapping, we have a reference to the maximum value,
  requiring another dereference (`*max_count`) when comparing in the filter.

  Both "hello" and "world" tie for the maximum count of 2, so both are included in
  the `frequent_words` vector. The vector is then sorted alphabetically to ensure
  deterministic output, resulting in ["hello", "world"].

  The key takeaway is understanding how the Entry API returns mutable references
  for efficient in-place updates, and how iterator methods like `max()` return
  references to avoid unnecessary copying of data.
