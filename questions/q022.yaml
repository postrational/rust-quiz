question: |-
  ```rust
  use std::rc::Rc;
  use std::cell::RefCell;

  fn main() {
      let data = Rc::new(RefCell::new(vec![1]));
      let weak = Rc::downgrade(&data);
      
      data.borrow_mut().push(2);
      
      drop(data);
      
      match weak.upgrade() {
          Some(rc) => println!("{:?}", rc.borrow()),
          None => println!("Gone"),
      }
  }
  ```

  What does this code output?
answers:
- '[1, 2]'
- '[1]'
- Gone
- Runtime panic
correct_answer: 2
expected_output:
- Gone
explanation: |-
  This question tests understanding of Rust's reference counting with `Rc` and
  `Weak` pointers, and how they interact with ownership and deallocation.

  The code creates an `Rc` (reference-counted pointer) containing a
  `RefCell<Vec<i32>>`. The `Rc::downgrade` function creates a `Weak` pointer,
  which is a non-owning reference that doesn't prevent the data from being
  deallocated.

  After pushing `2` to the vector (making it `[1, 2]`), the code explicitly calls
  `drop(data)`, which drops the only strong reference to the `Rc`. When the last
  strong reference to an `Rc` is dropped, the underlying data is immediately
  deallocated, regardless of whether any weak references still exist.

  When `weak.upgrade()` is called, it attempts to convert the weak reference back
  into a strong reference (`Rc`). However, since the data has already been
  deallocated, `upgrade()` returns `None`, and the code prints "Gone".

  The key takeaway is that `Weak` pointers do not keep data alive. They allow you
  to hold a reference that can be upgraded to a strong reference only if the data
  still exists. This pattern is useful for breaking reference cycles and for
  caching scenarios where you want to access data if it's still around but don't
  want to prevent its cleanup.
