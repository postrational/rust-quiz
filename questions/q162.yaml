question: |-
  ```rust
  use std::path::Path;

  fn main() {
      let paths = vec![
          "/usr/bin/../lib/file.so",
          "relative/path/../file",
          "../../../etc/passwd",
          "normal/path/file.txt"
      ];
      
      for path_str in paths {
          let path = Path::new(path_str);
          let parent = path.parent()
              .and_then(|p| p.file_name())
              .and_then(|name| name.to_str());
          
          println!("{}: {:?}", path_str, parent);
      }
  }
  ```

  What does this code print?
answers:
- '`Some("file.so")`, `Some("file")`, `Some("passwd")`, `Some("file.txt")`'
- '`Some("lib")`, `None`, `Some("etc")`, `Some("path")`'
- '`Some("lib")`, `Some("..")`, `Some("etc")`, `Some("path")`'
- All print `None` because parent directories cannot be determined from strings
correct_answer: 1
expected_output:
- '/usr/bin/../lib/file.so: Some("lib")'
- 'relative/path/../file: None'
- '../../../etc/passwd: Some("etc")'
- 'normal/path/file.txt: Some("path")'
explanation: |-
  This question tests understanding of Rust's `Path` API, specifically how
  `parent()` and `file_name()` work together when processing path strings.

  The code chains three operations for each path: `parent()` gets the parent
  directory, `file_name()` extracts the final component of that parent path, and
  `to_str()` converts it to a string.

  For `/usr/bin/../lib/file.so`, the parent is `/usr/bin/../lib`, and its file
  name component is `lib`, resulting in `Some("lib")`.

  For `relative/path/../file`, the parent is `relative/path/..`. The final
  component `..` is not a valid file name, so the result is `None`.

  For `../../../etc/passwd`, the parent is `../../../etc`, and its file name
  component is `etc`, resulting in `Some("etc")`.

  For `normal/path/file.txt`, the parent is `normal/path`, and its file name
  component is `path`, resulting in `Some("path")`.

  The key takeaway is that Rust's `Path` API performs lexical operations without
  filesystem access or path normalization. The `file_name()` method extracts the
  final component of a path, but returns `None` for special components like `..`
  and `.`, as these are not considered valid file names.