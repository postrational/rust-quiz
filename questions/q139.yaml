question: |-
  ```rust
  use std::sync::mpsc;
  use std::thread;

  fn main() {
      let (tx, rx) = mpsc::sync_channel(1);
      
      let handle = thread::spawn(move || {
          println!("T1");
          tx.send(1).unwrap();
          
          println!("T2");
          tx.send(2).unwrap();
          
          println!("T3");
          tx.send(3).unwrap();
      });
      
      thread::sleep(std::time::Duration::from_millis(50));
      println!("M1: {}", rx.recv().unwrap());
      
      thread::sleep(std::time::Duration::from_millis(50));
      println!("M2: {}", rx.recv().unwrap());
      
      thread::sleep(std::time::Duration::from_millis(50));
      println!("M3: {}", rx.recv().unwrap());
      
      handle.join().unwrap();
  }
  ```

  What does this print?
answers:
- 'T1, T2, M1: 1, T3, M2: 2, M3: 3'
- 'T1, M1: 1, T2, M2: 2, T3, M3: 3'
- 'T1, T2, T3, M1: 1, M2: 2, M3: 3'
- 'T1, T2, then panics because channel buffer is full'
correct_answer: 0
expected_output:
- 'T1'
- 'T2'
- 'M1: 1'
- 'T3'
- 'M2: 2'
- 'M3: 3'
explanation: |-
  This question tests understanding of synchronous channels and blocking behavior
  in Rust's message passing concurrency model. A synchronous channel created with
  `mpsc::sync_channel(1)` has a bounded capacity of 1, meaning it can buffer only
  one message before the sender blocks.
  
  The spawned thread prints `T1` and sends the first value (1), filling the buffer.
  When it attempts to send the second value (2), the buffer is full, so the thread
  blocks. It prints `T2` but then waits before the send completes.
  
  Meanwhile, the main thread sleeps for 50ms, then receives the first value,
  printing `M1: 1`. This frees up space in the buffer, unblocking the spawned
  thread to complete sending the second value. The thread then attempts to send
  the third value (3), prints `T3`, but blocks again because the buffer is full.
  
  The main thread sleeps again, receives the second value printing `M2: 2`, which
  unblocks the thread to complete sending the third value. Finally, the main thread
  sleeps once more, receives the third value printing `M3: 3`, and completes.
  
  The key insight is that synchronous channels with bounded capacity provide
  backpressure: senders block when the buffer is full, creating natural coordination
  between producer and consumer threads. This prevents producers from overwhelming
  consumers or consuming too much memory. Note that `send()` does not panic when the
  buffer is fullâ€”it blocks until space becomes available.