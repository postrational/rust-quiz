question: |-
  ```rust
  fn main() {
      let s = String::from("test");
      let r1 = &s;
      let r2 = &s;
      println!("{}", r1);
      let r3 = &mut s;
      println!("{}", r3);
  }
  ```

  What happens when you compile this code?
answers:
- Prints "test" twice
- 'Compilation error: cannot borrow `s` as mutable because it is also borrowed as immutable'
- 'Runtime panic: borrow conflict'
- 'Compilation error: `s` is not declared as mutable'
correct_answer: 3
expected_output:
- cannot borrow `s` as mutable, as it is not declared as mutable
explanation: |-
  This question tests understanding of Rust's mutability requirements for creating
  mutable references.
  
  The code attempts to create a mutable reference `r3` to `s` using `&mut s`.
  However, `s` is declared as `let s = ...` without the `mut` keyword, making it
  an immutable binding.
  
  In Rust, you can only create a mutable reference to a value if the binding itself
  is declared as mutable. To fix this code, `s` would need to be declared as
  `let mut s = String::from("test")`.
  
  The key takeaway is that mutability in Rust must be explicitly declared at the
  binding level. You cannot create mutable references to immutable bindings,
  regardless of other borrowing rules. This is part of Rust's philosophy of making
  mutability explicit and opt-in rather than default.
