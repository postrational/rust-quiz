question: |-
  ```rust
  fn parse_and_double(s: &str) -> Result<i32, String> {
      s.parse::<i32>()
          .map(|n| n * 2)
          .map_err(|e| format!("Parse failed: {}", e))
  }

  fn main() {
      let inputs = vec!["5", "not a number", "10"];
      
      let result: Vec<Result<i32, String>> = inputs
          .iter()
          .map(|s| parse_and_double(s))
          .collect();
      
      println!("{:?}", result);
  }
  ```
  
  What does this print?
answers:
- 'Err("Parse failed: invalid digit found in string")'
- '[Ok(10), Err("Parse failed: invalid digit found in string"), Ok(20)]'
- '[Ok(10), Err("Parse failed: invalid digit found in string")]'
- 'Compilation error: cannot collect iterator of `Result` into `Vec<Result<_, _>>`'
correct_answer: 1
expected_output:
- '[Ok(10), Err("Parse failed: invalid digit found in string"), Ok(20)]'
explanation: |-
  This question tests understanding of how collecting `Result` values into different
  container types affects error handling behavior.
  
  When the code processes the inputs:
  1. `"5"` parses successfully to `5`, doubled to `10`: `Ok(10)`
  2. `"not a number"` fails to parse: `Err("Parse failed: invalid digit found in string")`
  3. `"10"` parses successfully to `10`, doubled to `20`: `Ok(20)`
  
  When collecting into `Vec<Result<T, E>>`, all elements are processed without
  short-circuiting. Each result is preserved in the vector, allowing both successes
  and failures to coexist. All three results appear in the final vector.
  
  Note that if we collected into `Result<Vec<T>, E>` instead, the iterator would
  short-circuit at the first error and return `Err("Parse failed: invalid digit
  found in string")`, never processing the third element.
  
  The key takeaway is that the collection target type determines error handling:
  `Vec<Result<T, E>>` collects all results including errors, while `Result<Vec<T>, E>`
  provides fail-fast semantics that stop at the first error.
