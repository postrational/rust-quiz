question: |-
  ```rust
  use std::sync::{Arc, Mutex};
  use tokio::task;

  #[tokio::main]
  async fn main() {
      let counter = Arc::new(Mutex::new(0));
      let mut handles = vec![];
      
      for i in 0..3 {
          let counter_clone = Arc::clone(&counter);
          let handle = task::spawn(async move {
              let mut num = counter_clone.lock().unwrap();
              *num += 1;
              println!("Task {}: counter = {}", i, *num);
              drop(num); // Explicit unlock
          });
          handles.push(handle);
      }
      
      for handle in handles {
          handle.await.unwrap();
      }
      
      println!("Final counter: {}", *counter.lock().unwrap());
  }
  ```

  What's the behavior of this shared mutable state with Arc and Mutex?
answers:
- The code will not compile due to async/await issues
- 'All tasks print counter = 1, final counter: 1'
- 'All tasks print counter = 1, final counter: 3'
- 'Tasks print counter = 1, 2, 3 in some order, final counter: 3'
correct_answer: 3
expected_output:
- 'Task 0: counter = 1'
- 'Task 1: counter = 2'
- 'Task 2: counter = 3'
- 'Final counter: 3'
explanation: |-
  This question tests understanding of concurrent shared mutable state using
  `Arc<Mutex<T>>` in an async context with Tokio.

  The `Arc` (Atomic Reference Counting) allows multiple tasks to share ownership
  of the same `Mutex<i32>`. Each task clones the `Arc`, incrementing the reference
  count, so all tasks can access the same underlying mutex.

  The `Mutex` provides exclusive access to the counter. When a task calls
  `lock().unwrap()`, it acquires exclusive access to the value inside. While one
  task holds the lock, other tasks must wait. Each task increments the counter and
  prints the current value before releasing the lock.

  Because the mutex ensures sequential access to the counter, each task sees the
  cumulative effect of all previous increments. The first task to acquire the lock
  increments from 0 to 1, the second from 1 to 2, and the third from 2 to 3.
  However, due to concurrent task scheduling, the order in which tasks acquire the
  lock is non-deterministic, so the task IDs (0, 1, 2) may print in any order.

  The final counter value is always 3 because all three increments complete before
  the final print statement. The key takeaway is that `Arc<Mutex<T>>` is the
  standard pattern for safely sharing mutable state across threads or async tasks
  in Rust, combining shared ownership with exclusive access guarantees.
