question: |-
  ```rust
  fn main() {
      let v = vec![1, 2, 3, 4, 5];
      let result: Vec<i32> = v
          .iter()
          .enumerate()
          .filter_map(|(i, &x)| {
              if i % 2 == 0 {
                  Some(x * 2)
              } else {
                  None
              }
          })
          .collect();
      
      println!("{:?}", result);
  }
  ```

  What will this code print?
answers:
- '[2, 4, 6, 8, 10]'
- '[2, 6, 10]'
- '[1, 3, 5]'
- '[4, 8]'
correct_answer: 1
expected_output:
- '[2, 6, 10]'
explanation: |-
  This question tests understanding of Rust's iterator methods, specifically
  `enumerate` and `filter_map`.

  The iterator chain works as follows:

  1. `v.iter()` creates an iterator over references to the vector elements: `&1,
  &2, &3, &4, &5`
  2. `.enumerate()` adds zero-based indices to each element, producing tuples:
  `(0, &1), (1, &2), (2, &3), (3, &4), (4, &5)`
  3. `.filter_map(|(i, &x)| ...)` combines filtering and mapping in one operation:
     - Index 0, value 1: `0 % 2 == 0` is true, returns `Some(1 * 2)` = `Some(2)`
     - Index 1, value 2: `1 % 2 == 0` is false, returns `None` (filtered out)
     - Index 2, value 3: `2 % 2 == 0` is true, returns `Some(3 * 2)` = `Some(6)`
     - Index 3, value 4: `3 % 2 == 0` is false, returns `None` (filtered out)
     - Index 4, value 5: `4 % 2 == 0` is true, returns `Some(5 * 2)` = `Some(10)`
  4. `filter_map` automatically filters out `None` values and unwraps `Some`
  values, yielding: `2, 6, 10`
  5. `.collect()` gathers these into a `Vec<i32>`

  The key takeaway is that `filter_map` is an efficient way to combine filtering
  and transformation. The code selects elements at even indices (0, 2, 4) and
  doubles their values, producing `[2, 6, 10]`.
