question: |-
  ```rust
  use std::collections::HashMap;

  fn main() {
      let mut map = HashMap::new();
      
      for i in 0..5 {
          let entry = map.entry(i % 2);
          entry.and_modify(|v| *v += i).or_insert(i);
      }
      
      for key in [0, 1] {
          println!("{}: {}", key, map[&key]);
      }
  }
  ```

  What does this program print?
answers:
- '0: 6, 1: 4'
- '0: 0, 1: 1'
- '0: 4, 1: 6'
- '1: 4, 0: 6'
correct_answer: 0
expected_output:
- '0: 6'
- '1: 4'
explanation: |-
  This question tests understanding of the HashMap Entry API, specifically the
  `and_modify` and `or_insert` methods.

  The Entry API provides an efficient way to conditionally insert or update values
  in a HashMap. The `and_modify` method modifies an existing entry if present,
  while `or_insert` inserts a value if the entry doesn't exist.

  Tracing through the loop iterations:
  - i = 0: Key 0 doesn't exist, so `or_insert(0)` inserts 0 → {0: 0}
  - i = 1: Key 1 doesn't exist, so `or_insert(1)` inserts 1 → {0: 0, 1: 1}
  - i = 2: Key 0 exists, so `and_modify` adds 2 to the existing value: 0 + 2 = 2 →
  {0: 2, 1: 1}
  - i = 3: Key 1 exists, so `and_modify` adds 3 to the existing value: 1 + 3 = 4 →
  {0: 2, 1: 4}
  - i = 4: Key 0 exists, so `and_modify` adds 4 to the existing value: 2 + 4 = 6 →
  {0: 6, 1: 4}

  The final result shows that key 0 has value 6 (accumulated from 0 + 2 + 4) and
  key 1 has value 4 (accumulated from 1 + 3).

  The key takeaway is that the Entry API allows for efficient "insert or update"
  patterns without requiring multiple lookups. The `and_modify().or_insert()`
  chain is a common idiom for accumulator patterns where you want to update
  existing values or initialize new ones.
