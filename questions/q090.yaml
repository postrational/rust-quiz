question: |-
  ```rust
  fn main() {
      let numbers = vec![1, 2, 3, 4, 5];
      
      let result: Vec<_> = numbers
          .iter()
          .filter(|&&x| x > 2)
          .map(|&x| x * 2)
          .collect();
      
      println!("{:?}", result);
  }
  ```

  What does this print?
answers:
- '[6, 8, 10]'
- '[2, 4, 6, 8, 10]'
- '[3, 4, 5]'
- 'Compiler error: type mismatch in filter closure'
correct_answer: 0
expected_output:
- '[6, 8, 10]'
explanation: |-
  This question tests understanding of iterator adapters and pattern matching with
  references in closures.

  When `.iter()` is called on a `Vec<i32>`, it produces an iterator that yields
  `&i32` (references to the elements). This is why pattern matching is needed in
  the closures.

  In the `.filter(|&&x| x > 2)` closure:
  - The closure parameter receives a reference to what the iterator yields, so it
  has type `&&i32`
  - The pattern `&&x` unpacks this double reference: the first `&` matches the
  closure's reference parameter, and the second `&` matches the reference from
  `.iter()`
  - After pattern matching, `x` has type `i32` and can be compared directly with
  `2`
  - This filters out elements 1 and 2, keeping only 3, 4, and 5

  In the `.map(|&x| x * 2)` closure:
  - The closure receives `&i32` (what the filtered iterator yields)
  - The pattern `&x` unpacks the reference, giving `x` type `i32`
  - Each value is multiplied by 2: 3→6, 4→8, 5→10

  The key takeaway is that `.iter()` yields references, and closures in iterator
  adapters receive references to those items. Pattern matching with `&` in closure
  parameters is a concise way to dereference and extract the underlying values.
  Understanding this reference layering is essential for working effectively with
  Rust iterators.
