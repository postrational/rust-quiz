question: |-
  ```rust
  struct Matrix<T, const ROWS: usize, const COLS: usize> {
      data: [[T; COLS]; ROWS],
  }

  impl<T: Default + Copy, const ROWS: usize, const COLS: usize> Matrix<T, ROWS, COLS> {
      fn new() -> Self {
          Matrix {
              data: [[T::default(); COLS]; ROWS],
          }
      }
      
      fn size(&self) -> usize {
          ROWS * COLS
      }
  }

  fn main() {
      let matrix: Matrix<i32, 3, 4> = Matrix::new();
      println!("{}", matrix.size());
      
      let different: Matrix<f64, 2, 5> = Matrix::new();
      println!("{}", different.size());
      
      println!("{}", std::mem::size_of::<Matrix<u8, 100, 100>>());
  }
  ```

  What does this code output?
answers:
- 12, 10, 10000
- 12, 10, 10008
- Compilation error - const generics not stable
- 7, 7, 10000
correct_answer: 0
expected_output:
- '12'
- '10'
- '10000'
explanation: |-
  This question tests understanding of const generics in Rust, which allow types
  to be parameterized by constant values rather than just types. Const generics
  have been stable since Rust 1.51.

  In this code, `Matrix<T, const ROWS: usize, const COLS: usize>` uses three
  generic parameters: `T` is a traditional type parameter, while `ROWS` and `COLS`
  are const generic parameters that represent compile-time constant values.

  The `size()` method returns `ROWS * COLS`, which is computed at compile time.
  For `Matrix<i32, 3, 4>`, this evaluates to 3 * 4 = 12. For `Matrix<f64, 2, 5>`,
  it evaluates to 2 * 5 = 10.

  The `std::mem::size_of` call calculates the memory size of `Matrix<u8, 100,
  100>`. Since `u8` is 1 byte and the matrix contains 100 * 100 = 10,000 elements,
  the total size is 10,000 bytes. The struct has no additional overhead because it
  only contains the array data.

  Key takeaways about const generics:
  - They enable compile-time parameterization by values, not just types
  - Different const values create distinct types (e.g., `Matrix<i32, 3, 4>` and
  `Matrix<i32, 4, 3>` are different types)
  - Computations using const generics happen at compile time with zero runtime
  cost
  - They're particularly useful for fixed-size arrays, matrices, and other data
  structures where dimensions are known at compile time
