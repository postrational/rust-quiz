question: |-
  ```rust
  trait Container<T> {
      fn get(&self) -> &T;
  }

  struct Wrapper<T> {
      value: T,
  }

  impl<T> Container<T> for Wrapper<T> {
      fn get(&self) -> &T {
          &self.value
      }
  }

  fn process<T, C: Container<T>>(container: &C) -> &T {
      container.get()
  }

  fn main() {
      let w1 = Wrapper { value: 42 };
      let w2 = Wrapper { value: "hello" };
      
      let r1 = process(&w1);
      let r2 = process(&w2);
      
      println!("{}", r1);
      println!("{}", r2);
  }
  ```

  What will this code print?
answers:
- 42, hello
- 'Compilation error: type mismatch'
- 'Compilation error: cannot infer type for T'
- '42, Wrapper { value: "hello" }'
correct_answer: 0
expected_output:
- '42'
- hello
explanation: |-
  This question tests understanding of generic traits, generic functions, and type
  inference in Rust.

  The code defines a generic trait `Container<T>` with a method that returns a
  reference to a value of type `T`. The `Wrapper<T>` struct is a generic container
  that can hold any type, and it implements `Container<T>` for any type `T`.

  The `process` function is generic over two type parameters: `T` (the contained
  type) and `C` (the container type that implements `Container<T>`). This function
  takes a reference to any container and returns a reference to the contained
  value.

  In `main`, two `Wrapper` instances are created: `w1` contains an `i32` value of
  42, and `w2` contains a `&str` value of "hello". When `process(&w1)` is called,
  Rust infers that `T` is `i32` and `C` is `Wrapper<i32>`. Similarly, for
  `process(&w2)`, Rust infers `T` as `&str` and `C` as `Wrapper<&str>`.

  The type inference works seamlessly because Rust can determine all the generic
  type parameters from the context: the type of the argument passed to `process`
  provides enough information to infer both `T` and `C`. The function returns
  references to the contained values, which are then printed.

  The key takeaway is that Rust's type inference is powerful enough to handle
  multiple generic type parameters when there are sufficient constraints and
  context. Generic traits allow for flexible abstractions that work with any type
  while maintaining type safety.
