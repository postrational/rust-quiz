question: |-
  ```rust
  use std::borrow::Cow;

  #[derive(Clone, Debug, PartialEq)]
  struct MyData {
      value: i32,
  }

  fn process_data(data: Cow<[MyData]>) -> Cow<[MyData]> {
      if data.len() <= 2 {
          data  // Return as-is
      } else {
          let mut owned = data.into_owned();
          owned.push(MyData { value: 999 });
          Cow::Owned(owned)
      }
  }

  fn main() {
      let slice = [MyData { value: 1 }, MyData { value: 2 }];
      let vec = vec![MyData { value: 3 }, MyData { value: 4 }, MyData { value: 5 }];
      
      let result1 = process_data(Cow::Borrowed(&slice));
      let result2 = process_data(Cow::Owned(vec));
      
      println!("{}", result1.len());
      println!("{}", result2.len());
  }
  ```

  What does this code output?
answers:
- 2, 4
- 2, 3
- 3, 4
- Compilation error - cannot use Cow with custom types
correct_answer: 0
expected_output:
- '2'
- '4'
explanation: |-
  This question tests understanding of `Cow` (Clone-on-Write) with custom types
  and how it handles borrowed versus owned data.

  The `Cow` type works with any type that implements `Clone` and `ToOwned`, not
  just strings. In this case, `Cow<[MyData]>` is used with a custom struct that
  derives `Clone`.

  For the first call with `process_data(Cow::Borrowed(&slice))`:
  - The input is a borrowed slice containing 2 elements
  - Since `data.len() <= 2`, the function returns the data as-is without
  modification
  - The result is still `Cow::Borrowed` with 2 elements
  - Output: `2`

  For the second call with `process_data(Cow::Owned(vec))`:
  - The input is an owned vector containing 3 elements
  - Since `data.len() > 2` (3 is greater than 2), the else branch executes
  - `data.into_owned()` converts the `Cow` to an owned `Vec`. Since it's already
  owned, no cloning occurs
  - A new element `MyData { value: 999 }` is pushed, making the length 4
  - The result is `Cow::Owned` with 4 elements
  - Output: `4`

  The key takeaway is that `Cow` provides efficient copy-on-write semantics for
  any cloneable type. The `into_owned()` method intelligently handles both cases:
  it clones borrowed data when necessary, but simply takes ownership when the data
  is already owned, avoiding unnecessary allocations.
