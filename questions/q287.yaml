question: |-
  ```rust
  fn main() {
      let mut s = String::from("test");
      let r1 = &s;
      let r2 = &s;
      println!("{}", r1);
      let r3 = &mut s;
      println!("{}", r3);
  }
  ```

  What does this code output?
answers:
- Prints "test" twice
- 'Compilation error: cannot borrow `s` as mutable because it is also borrowed as immutable'
- 'Runtime panic: borrow conflict'
- 'Compilation error: immutable borrows still active'
correct_answer: 0
expected_output:
- test
- test
explanation: |-
  This question tests understanding of Rust's Non-Lexical Lifetimes (NLL), a
  feature that makes the borrow checker more precise about when borrows are
  actually active.

  In this code, two immutable references `r1` and `r2` are created first, followed
  by a mutable reference `r3`. At first glance, this might seem like it should
  violate Rust's borrowing rules, which state that you cannot have a mutable
  reference while immutable references exist. However, the key insight is that NLL
  tracks when references are actually *used*, not just when they go out of scope.

  The immutable references `r1` and `r2` are last used in the first `println!`
  statement. After that point, their lifetimes effectively end, even though
  they're still technically in scope. When `r3` is created as a mutable reference,
  the borrow checker recognizes that no immutable references are actively being
  used anymore, so the mutable borrow is allowed.

  The code successfully compiles and prints "test" twice: once from `r1` and once
  from `r3`. This demonstrates how NLL makes Rust's borrow checker more ergonomic
  by understanding the actual usage patterns of references rather than relying
  solely on lexical scope.
