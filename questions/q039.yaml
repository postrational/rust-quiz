question: |-
  ```rust
  fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
      if x.len() > y.len() {
          x
      } else {
          y
      }
  }

  fn main() {
      let string1 = String::from("long string is long");
      
      {
          let string2 = String::from("xyz");
          let result = longest(string1.as_str(), string2.as_str());
          println!("{}", result);
      }
  }
  ```

  What does this code output?
answers:
- long string is long
- xyz
- Compilation error - `string2` doesn't live long enough
- Compilation error - lifetime parameter mismatch
correct_answer: 0
expected_output:
- long string is long
explanation: |-
  This question tests understanding of how lifetime parameters work with function
  signatures and the borrow checker's validation rules.

  The `longest` function has a lifetime parameter `'a` that applies to both input
  references and the return reference. This signature tells the compiler that the
  returned reference will be valid for at least as long as the shorter of the two
  input lifetimes.

  In this code:
  1. `string1` lives for the entire `main` function scope
  2. `string2` lives only within the inner block
  3. The lifetime `'a` is constrained to the shorter lifetime, which is
  `string2`'s scope
  4. The `result` reference is used (printed) within the same block where
  `string2` is valid
  5. Since `"long string is long".len() > "xyz".len()` evaluates to true, the
  function returns `x` (a reference to `string1`)

  The code compiles successfully because `result` is only used within the scope
  where both input references are valid. Even though the function returns a
  reference to `string1`, the lifetime `'a` represents the intersection of both
  input lifetimes, and the borrow checker verifies that `result` doesn't outlive
  this constraint.

  The key takeaway is that lifetime parameters don't extend or shorten actual
  lifetimesâ€”they express relationships between lifetimes that the compiler can
  verify. The returned reference is valid as long as it's used within the scope
  where all inputs with that lifetime annotation are valid.
