question: |-
  ```rust
  use std::collections::HashMap;

  fn main() {
      let mut map = HashMap::new();
      map.insert("x", 10);
      
      let result = map.entry("x").and_modify(|v| *v *= 2).or_insert(5);
      println!("{}", result);
  }
  ```

  What does this program print?
answers:
- '5'
- '10'
- '20'
- Compilation error
correct_answer: 2
expected_output:
- '20'
explanation: |-
  This question tests understanding of the Entry API in Rust's HashMap,
  specifically the `and_modify` and `or_insert` methods.

  The Entry API provides an efficient way to conditionally modify or insert values
  with a single hash lookup. Here's how the method chain works:

  1. `map.entry("x")` retrieves the entry for key "x". Since the key exists with
  value 10, this returns an `Occupied` entry.

  2. `and_modify(|v| *v *= 2)` is called on the occupied entry. This method
  applies the closure to modify the existing value in-place. The value 10 is
  multiplied by 2, becoming 20. If the entry were vacant, this method would do
  nothing and the closure would not be called.

  3. `or_insert(5)` is then called, but since the entry is already occupied, this
  method does nothing. The value 5 would only be inserted if the entry were
  vacant.

  4. The method chain returns a mutable reference to the value in the map, which
  is now 20.

  The key takeaway is that `and_modify` allows you to modify existing values while
  `or_insert` provides a default for missing keys. This pattern is commonly used
  for operations like incrementing counters: `map.entry(key).and_modify(|v| *v +=
  1).or_insert(1)`. This approach is more efficient than separate lookups because
  it performs only one hash table lookup for the entire operation.
