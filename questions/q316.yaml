question: |-
  ```rust
  use std::collections::VecDeque;

  fn main() {
      let mut deque: VecDeque<i32> = VecDeque::new();
      deque.extend([1, 2, 3, 4, 5]);
      
      let middle = deque.remove(2).unwrap();
      deque.insert(1, middle);
      
      println!("{:?}", deque);
  }
  ```

  What does this program print?
answers:
- '[1, 3, 2, 4, 5]'
- '[1, 2, 4, 5, 3]'
- '[3, 1, 2, 4, 5]'
- 'Runtime panic: index out of bounds'
correct_answer: 0
expected_output:
- '[1, 3, 2, 4, 5]'
explanation: |-
  This question tests understanding of VecDeque's `remove` and `insert` operations
  and how they affect element positions.

  Starting with a VecDeque containing [1, 2, 3, 4, 5], the code performs two
  operations:

  1. `deque.remove(2).unwrap()` removes the element at index 2 (the value 3) and
  returns it. After this operation, the deque contains [1, 2, 4, 5] with indices
  0, 1, 2, 3 respectively.

  2. `deque.insert(1, middle)` inserts the value 3 at index 1. The `insert` method
  places the new element at the specified index and shifts all existing elements
  at that index and beyond to the right. Since index 1 currently holds the value
  2, that value and all subsequent elements shift right, resulting in [1, 3, 2, 4,
  5].

  The key takeaway is understanding that `insert` places an element at a specific
  index and shifts existing elements to make room, rather than replacing them.
  VecDeque provides efficient insertion and removal at both ends, but operations
  in the middle (like these) require shifting elements and have O(n) complexity.
