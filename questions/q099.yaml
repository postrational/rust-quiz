question: |-
  ```rust
  fn main() {
      let numbers = vec![1, 2, 3, 4, 5];
      
      let result = numbers
          .iter()
          .scan(0, |state, &x| {
              *state += x;
              Some(*state)
          })
          .collect::<Vec<_>>();
      
      println!("{:?}", result);
  }
  ```

  What does this print?
answers:
- '[1, 3, 6, 10, 15]'
- '[0, 1, 3, 6, 10]'
- '[1, 2, 3, 4, 5]'
- 'Compiler error: cannot mutate captured variable'
correct_answer: 0
expected_output:
- '[1, 3, 6, 10, 15]'
explanation: |-
  This question tests understanding of the `scan` iterator adapter in Rust. The
  `scan` method is similar to `fold`, but instead of producing a single final
  value, it produces an iterator that yields intermediate values at each step.

  The `scan` method takes two parameters: an initial state value (0 in this case)
  and a closure that receives a mutable reference to the state and each element
  from the iterator. The closure can modify the state and returns an `Option`. If
  it returns `Some(value)`, that value is yielded by the iterator; if it returns
  `None`, the iteration stops.

  In this code, the scan starts with state = 0. For each element in the vector:
  - Element 1: state becomes 0 + 1 = 1, yields 1
  - Element 2: state becomes 1 + 2 = 3, yields 3
  - Element 3: state becomes 3 + 3 = 6, yields 6
  - Element 4: state becomes 6 + 4 = 10, yields 10
  - Element 5: state becomes 10 + 5 = 15, yields 15

  The result is a running sum (cumulative sum) of the elements: `[1, 3, 6, 10,
  15]`.

  The key takeaway is that `scan` is useful for computing running aggregations
  where you need to see the intermediate results at each step, not just the final
  accumulated value. The closure is allowed to mutate the state because `scan`
  provides a mutable reference to it.
