question: |-
  ```rust
  struct Matrix<const N: usize> {
      data: [[i32; N]; N],
  }

  impl<const N: usize> Matrix<N> {
      fn transpose(&self) -> Matrix<N> {
          let mut result = [[0; N]; N];
          for i in 0..N {
              for j in 0..N {
                  result[j][i] = self.data[i][j];
              }
          }
          Matrix { data: result }
      }
  }

  fn main() {
      let m1: Matrix<2> = Matrix { data: [[1, 2], [3, 4]] };
      let m2: Matrix<3> = Matrix { data: [[1, 2, 3], [4, 5, 6], [7, 8, 9]] };
      
      let t1 = m1.transpose();
      let t2 = m2.transpose();
      
      println!("{}", t1.data[0][1]);
      println!("{}", t2.data[1][0]);
  }
  ```

  What will this code print?
answers:
- 3, 2
- 2, 4
- 3, 4
- Compilation error - const generics cannot be used with arrays
correct_answer: 0
expected_output:
- '3'
- '2'
explanation: |-
  This question tests understanding of const generics in Rust, which allow types
  to be parameterized by constant values rather than just other types.

  The `Matrix<const N: usize>` struct uses a const generic parameter `N` to define
  a square matrix of size N×N. This means the size is known at compile time and
  different sizes are actually different types - `Matrix<2>` and `Matrix<3>` are
  distinct types.

  The `transpose` method works for any size matrix because it's generic over `N`.
  For a matrix transpose, element at position [i][j] moves to position [j][i].

  For `m1` (2×2 matrix [[1, 2], [3, 4]]):
  - After transpose: [[1, 3], [2, 4]]
  - `t1.data[0][1]` accesses row 0, column 1 = 3

  For `m2` (3×3 matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]]):
  - After transpose: [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
  - `t2.data[1][0]` accesses row 1, column 0 = 2

  The key takeaway is that const generics enable compile-time parameterization by
  values, allowing for type-safe, zero-cost abstractions where array sizes and
  other constants are part of the type system. This provides better type safety
  than runtime-sized collections when dimensions are known at compile time.
