question: |-
  ```rust
  use std::cell::Cell;

  fn main() {
      let x = Cell::new(42);
      let y = &x;
      let z = &x;
      
      y.set(100);
      println!("{}", z.get());
      z.set(200);
      println!("{}", y.get());
      println!("{}", x.get());
  }
  ```

  What does this code output?
answers:
- 100, 200, 200
- 42, 100, 200
- Compilation error - multiple mutable references
- 100, 200, 42
correct_answer: 0
expected_output:
- '100'
- '200'
- '200'
explanation: |-
  This question tests understanding of `Cell<T>` and interior mutability in Rust.
  `Cell<T>` is a type that provides interior mutability for `Copy` types, allowing
  mutation through shared (immutable) references.

  In this code, `x` is a `Cell<i32>` initially containing the value 42. Both `y`
  and `z` are immutable references (`&Cell<i32>`) to the same `Cell`. Despite
  being immutable references, they can mutate the cell's contents using the
  `set()` method and read values using the `get()` method.

  When `y.set(100)` is called, it changes the cell's internal value to 100. Since
  `y`, `z`, and `x` all refer to the same `Cell`, when `z.get()` is called, it
  reads the current value of 100. Next, `z.set(200)` changes the value to 200, so
  both `y.get()` and `x.get()` return 200.

  The key takeaway is that `Cell` allows mutation through shared references
  without violating Rust's borrowing rules. It achieves this by only allowing you
  to get or set the entire value (which must be `Copy`), never providing direct
  mutable access to the contents. This is different from `RefCell`, which uses
  runtime borrow checking and can work with non-`Copy` types. `Cell` is useful
  when you need simple interior mutability for small `Copy` types without the
  overhead of runtime checks.
