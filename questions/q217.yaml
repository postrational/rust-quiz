question: |-
  ```rust
  trait MyTrait {
      fn method(&self) -> Self;
  }

  struct MyStruct;

  impl MyTrait for MyStruct {
      fn method(&self) -> Self {
          MyStruct
      }
  }

  fn main() {
      let s = MyStruct;
      let _trait_obj: &dyn MyTrait = &s;
      println!("Success");
  }
  ```

  What happens when you try to compile this code?
answers:
- The code compiles and prints `Success`
- 'Compilation error: the trait `MyTrait` is not dyn compatible because method `method` references the `Self` type in its return type'
- 'Compilation error: trait objects must be behind a pointer'
- Runtime panic occurs when creating the trait object
correct_answer: 1
expected_output:
- the trait `MyTrait` is not dyn compatible
- method `method` references the `Self` type in its return type
explanation: |-
  This question tests understanding of dyn compatibility (formerly called object
  safety) in Rust, which determines whether a trait can be used as a trait object
  (e.g., `&dyn Trait`).

  A trait is dyn compatible only if it meets certain criteria. One key requirement
  is that methods cannot return `Self` by value. The reason is that when using a
  trait object, the concrete type is erased at runtimeâ€”the compiler only knows
  it's "some type that implements this trait." If a method returns `Self`, the
  compiler wouldn't know the size of the return value at compile time, making it
  impossible to generate correct code.

  In this code, the `method` function has a return type of `Self`, which violates
  dyn compatibility rules. When the code attempts to create a trait object `&dyn
  MyTrait`, the compiler detects this violation and produces a compilation error
  indicating that `MyTrait` is not dyn compatible because `method` references
  `Self` in its return type.

  To make a trait dyn compatible, methods should either:
  - Return concrete types or trait objects (like `Box<dyn Trait>`)
  - Use `where Self: Sized` bounds to exclude the method from trait object vtables
  - Avoid returning `Self` by value

  The key takeaway is that not all traits can be used as trait objects. Dyn
  compatibility rules ensure that trait objects can be used safely with dynamic
  dispatch, where the concrete type is only known at runtime.
