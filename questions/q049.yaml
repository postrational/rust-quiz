question: |-
  ```rust
  trait IsEven {
      const VALUE: bool;
  }

  struct Even;
  struct Odd;

  impl IsEven for Even {
      const VALUE: bool = true;
  }

  impl IsEven for Odd {
      const VALUE: bool = false;
  }

  struct Array<T, const N: usize, P> 
  where 
      P: IsEven,
      [(); N]:
  {
      data: [T; N],
      _parity: std::marker::PhantomData<P>,
  }

  impl<T: Default + Copy, const N: usize> Array<T, N, Even> {
      fn new_even() -> Self 
      where 
          [(); N % 2]: { todo!() }
  }

  fn main() {
      // Which of these would compile if implemented correctly?
      let arr1: Array<i32, 4, Even> = Array::new_even(); // A
      let arr2: Array<i32, 5, Even> = Array::new_even(); // B  
      let arr3: Array<i32, 4, Odd> = Array::new_odd();   // C
      
      println!("Compilation analysis complete");
  }
  ```

  Which of these would compile if implemented correctly?
answers:
- Only A compiles
- A and C compile
- This is too complex - const generics can't do this
- All would compile with correct implementations
correct_answer: 2
expected_output:
- generic parameters may not be used in const operations
explanation: |-
  This question tests understanding of const generics limitations in Rust's type system.
  The `Array` struct uses `N` for array size and `P` as a parity marker (Even/Odd).
  The intent is to enforce that only even-sized arrays can use `new_even()`.
  
  The critical limitation: `where [(); N % 2]:` in `new_even()` triggers the error
  "generic parameters may not be used in const operations." While the syntax is valid,
  the type system cannot evaluate const expressions containing generic parameters
  in where clause constraints.
  
  Compare the struct definition: `where [(); N]:` works because it uses `N` directly
  as a const parameter without arithmetic operations. However, `where [(); N % 2]:` 
  requires evaluating arithmetic on a generic parameter in a constraint context,
  which Rust's current type system cannot handle.
  
  All three cases would fail to compile:
  - **A and B**: Fail at method definition with "generic parameters may not be used 
    in const operations" due to `N % 2` in the where clause
  - **C**: Fails because `new_odd()` method is not defined
  
  This demonstrates a fundamental limitation: while const generics allow using 
  constant values as type parameters, they cannot perform arithmetic on generic
  parameters in where clause constraints. Interestingly, `[T; N % 2]` would work
  as a field type (creating an array of computed size), but the same expression
  fails when used to constrain types in where clauses.
  
  Practical alternatives include runtime checks, macro-generated implementations,
  or using the unstable `generic_const_exprs` feature for more complex const reasoning.

  Please submit a better explanation for this in a GitHub PR if you can...
