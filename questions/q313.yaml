question: |-
  ```rust
  use std::collections::BTreeMap;

  fn main() {
      let mut map = BTreeMap::new();
      map.insert(5, "five");
      map.insert(2, "two");
      map.insert(8, "eight");
      map.insert(1, "one");
      
      let first_key = *map.keys().next().unwrap();
      let last_key = *map.keys().last().unwrap();
      
      println!("{} {}", first_key, last_key);
  }
  ```

  What does this program print?
answers:
- 5 1
- 1 8
- 2 8
- 8 1
correct_answer: 1
expected_output:
- 1 8
explanation: |-
  This question tests understanding of BTreeMap's ordering behavior in Rust.
  Unlike HashMap, which has no guaranteed ordering, BTreeMap maintains its keys in
  sorted order according to the key type's natural ordering (via the Ord trait).

  In this code, keys are inserted in the order 5, 2, 8, 1. However, BTreeMap
  internally stores them in sorted order: {1: "one", 2: "two", 5: "five", 8:
  "eight"}. When iterating over the keys, they are always returned in this sorted
  order.

  The `keys().next().unwrap()` call retrieves the first key in the sorted order,
  which is 1 (the smallest key). The `keys().last().unwrap()` call retrieves the
  last key in the sorted order, which is 8 (the largest key). Therefore, the
  program prints "1 8".

  The key takeaway is that BTreeMap is useful when you need ordered iteration,
  range queries, or predictable ordering of elements. This is in contrast to
  HashMap, which offers faster average-case performance but no ordering
  guarantees.
