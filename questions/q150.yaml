question: |-
  ```rust
  use std::sync::{Arc, Mutex};
  use std::thread;

  fn main() {
      let data = Arc::new(Mutex::new(vec![1, 2, 3]));
      let handles: Vec<_> = (0..3)
          .map(|i| {
              let data = Arc::clone(&data);
              thread::spawn(move || {
                  let mut v = data.lock().unwrap();
                  v.push(i);
              })
          })
          .collect();
      
      for handle in handles {
          handle.join().unwrap();
      }
      
      let final_data = data.lock().unwrap();
      println!("Length: {}", final_data.len());
  }
  ```

  What will this code print?
answers:
- 'Length: 3'
- 'Length: 6'
- Compilation error - cannot move out of borrowed content
- Deadlock - threads wait forever
correct_answer: 1
expected_output:
- 'Length: 6'
explanation: |-
  This question tests understanding of `Arc<Mutex<T>>` for shared mutable state
  across threads in Rust.

  The code creates a vector `[1, 2, 3]` wrapped in `Mutex` for interior mutability
  and `Arc` for shared ownership across threads. Three threads are spawned, each
  receiving a cloned `Arc` pointer to the same underlying data.

  Each thread acquires the mutex lock, pushes a value (0, 1, or 2) to the vector,
  and then the lock is automatically released when the `MutexGuard` goes out of
  scope at the end of the closure. The main thread waits for all spawned threads
  to complete via `join()`, ensuring all three push operations finish before the
  final length check.

  The original vector has 3 elements, and each of the 3 threads adds one more
  element, resulting in a total of 6 elements. The order of elements may vary due
  to thread scheduling, but the length is deterministic.

  Key concepts demonstrated:
  - `Arc` provides thread-safe reference counting for shared ownership
  - `Mutex` provides interior mutability with exclusive access guarantees
  - `MutexGuard` automatically releases the lock when dropped (RAII pattern)
  - `join()` ensures synchronization before accessing final results

  This is the standard pattern for sharing mutable state across threads in safe
  Rust.
