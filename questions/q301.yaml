question: |-
  ```rust
  use std::collections::BinaryHeap;

  fn main() {
      let mut heap = BinaryHeap::new();
      heap.push(3);
      heap.push(1);
      heap.push(4);
      heap.push(2);
      
      println!("{}", heap.pop().unwrap());
      println!("{}", heap.pop().unwrap());
  }
  ```

  What does this program print?
answers:
- 3, 1
- 1, 2
- 4, 3
- 2, 4
correct_answer: 2
expected_output:
- '4'
- '3'
explanation: |-
  This question tests understanding of Rust's BinaryHeap data structure and its
  ordering behavior. BinaryHeap in Rust implements a max-heap by default, which
  means it maintains the largest element at the top of the heap.

  When elements are pushed onto the heap (3, 1, 4, 2), the BinaryHeap
  automatically maintains the max-heap property through internal reorganization.
  The largest element is always accessible at the top.

  When `pop()` is called, it removes and returns the maximum element from the
  heap. The first `pop()` returns 4 (the largest element), and the second `pop()`
  returns 3 (the next largest element after 4 is removed).

  The key takeaway is that BinaryHeap is a max-heap that provides O(log n)
  insertion and O(log n) removal of the maximum element. This makes it ideal for
  implementing priority queues where you need efficient access to the
  highest-priority (largest) item. If you need a min-heap instead, you can wrap
  your values in `Reverse` from `std::cmp`.
